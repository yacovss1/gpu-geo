/**
 * Compute Output Shaders
 * 
 * Shaders for rendering geometry generated by the terrain compute pipeline.
 * Uses a different vertex layout: position(3) + normal(3) + color(4) = 40 bytes
 */

export const computeOutputVertexShader = `
struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec4<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) worldPos: vec3<f32>
};

@group(0) @binding(0) var<uniform> cameraMatrix: mat4x4<f32>;

@vertex
fn main(
    @location(0) inPosition: vec3<f32>,
    @location(1) inNormal: vec3<f32>,
    @location(2) inColor: vec4<f32>
) -> VertexOutput {
    var output: VertexOutput;
    
    // Position already includes terrain height from compute shader
    let pos = vec4<f32>(inPosition, 1.0);
    output.position = cameraMatrix * pos;
    
    output.color = inColor;
    output.normal = inNormal;
    output.worldPos = inPosition;
    
    return output;
}
`;

export const computeOutputFragmentShader = `
@fragment
fn main(
    @location(0) color: vec4<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) worldPos: vec3<f32>
) -> @location(0) vec4<f32> {
    // Simple directional lighting
    let lightDir = normalize(vec3<f32>(0.3, 0.5, 1.0));
    let lightIntensity = max(dot(normal, lightDir), 0.3);
    
    // Apply lighting to color
    return vec4<f32>(
        color.rgb * lightIntensity,
        color.a
    );
}
`;
